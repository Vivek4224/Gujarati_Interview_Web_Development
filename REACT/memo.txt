### **1. What is `React.memo`?**

**ઉત્તર**:  
`React.memo` એ એક હાઈઅર-ઓર્ડર કોમ્પોનન્ટ છે જે ફંક્શનલ કોમ્પોનન્ટ્સને ઑપ્ટિમાઇઝ કરવામાં મદદ કરે છે. તે મેમોાઇઝ કરીને કોમ્પોનન્ટ્સને અનાવશ્યક રીરેન્ડર્સથી બચાવે છે જ્યારે તેની પ્રોપ્સ બદલાતી નથી. તે માત્ર ત્યારે જ રીરેન્ડર કરે છે જ્યારે તેને નવો પ્રોપ્સ મળતા હોય.

```jsx
const MyComponent = React.memo(function MyComponent(props) {
  // કોમ્પોનન્ટ લોજિક
  return <div>{props.value}</div>;
});
```

---

### **2. `React.memo` કેવી રીતે પ્રદર્શનને સુધારે છે?**

**ઉત્તર**:  
`React.memo` ફંક્શનલ કોમ્પોનન્ટ્સના રીરેન્ડરિંગને સ્કિપ કરીને પ્રદર્શનને સુધારે છે, જ્યારે પ્રોપ્સ બદલાતા નથી. આ ખાસ કરીને ત્યારે ઉપયોગી છે જ્યારે એક કોમ્પોનન્ટને પછતા રેન્ડરો પર આ mesma પ્રોપ્સ મળે છે, જે અન્યથા અનાવશ્યક અપડેટ્સને કારણે થશે.

---

### **3. `React.memo` ને ફંક્શનલ કોમ્પોનન્ટ સાથે કેવી રીતે ઉપયોગ કરશો?**

**ઉત્તર**:  
તમે `React.memo` સાથે ફંક્શનલ કોમ્પોનન્ટને લપેટી શકો છો જેથી મેમોાઇઝેશન સક્રિય થઈ જાય. આને કારણે કોમ્પોનન્ટ માત્ર ત્યારે જ રીરેન્ડર થશે જ્યારે પ્રોપ્સ બદલાય.

```jsx
const MyComponent = React.memo(function MyComponent({ name }) {
  console.log('Rendering:', name);
  return <div>{name}</div>;
});
```

---

### **4. શું `React.memo` ડિફોલ્ટ રીતે કોમ્પોનન્ટના તમામ પ્રોપ્સની તુલના કરે છે?**

**ઉત્તર**:  
હા, ડિફોલ્ટ રૂપે `React.memo` કોમ્પોનન્ટના પ્રોપ્સની શેલો તુલના કરે છે. જો પ્રોપ્સ જટિલ (જેમ કે ઑબ્જેક્ટ્સ અથવા એરે) હોય, તો તે અનાવશ્યક રીરેન્ડર જાહેર કરી શકે છે, ભલે સામગ્રી એ બદલાઈ ન હોય. તમે તેને વધુ ઑપ્ટિમાઇઝ કરવા માટે કસ્ટમ તુલના કાર્ય ઉપયોગ કરી શકો છો.

ડિફોલ્ટ શેલો તુલના સાથે ઉદાહરણ:

```jsx
const MyComponent = React.memo(function MyComponent({ name, age }) {
  return <div>{name} is {age}</div>;
});
```

---

### **5. તમે `React.memo` ને કસ્ટમ તુલના કાર્ય કેવી રીતે પ્રદાન કરી શકો છો?**

**ઉત્તર**:  
તમે `React.memo` માં એક બીજું દલીલ પસાર કરી શકો છો, જે કસ્ટમ તુલના કાર્ય છે, જે વર્તમાન પ્રોપ્સ અને આગામી પ્રોપ્સની તુલના કરે છે. આ રીતે તમે નિયંત્રિત કરી શકો છો કે કોમ્પોનન્ટ ક્યારે રીરેન્ડર થશે.

```jsx
const MyComponent = React.memo(
  function MyComponent({ name, age }) {
    return <div>{name} is {age}</div>;
  },
  (prevProps, nextProps) => {
    return prevProps.name === nextProps.name && prevProps.age === nextProps.age;
  }
);
```

આ ઉદાહરણમાં, કોમ્પોનન્ટ માત્ર ત્યારે જ રીરેન્ડર થશે જ્યારે `name` અથવા `age` પ્રોપ બદલાય.



### **6. શું `React.memo` કલેક્શન કોમ્પોનન્ટ્સ સાથે ઉપયોગ કરી શકાય છે?**

**ઉત્તર**:  
નહીં, `React.memo` માત્ર ફંક્શનલ કોમ્પોનન્ટ્સ સાથે કામ કરે છે. જો તમે કલેક્શન કોમ્પોનન્ટમાં સમાન કાર્યક્ષમતા જોઈએ છો, તો તમે `PureComponent` નો ઉપયોગ કરી શકો છો, જે કોમ્પોનન્ટના પ્રોપ્સ અને સ્ટેટના શેલો કોમ્પેરિઝનને કરે છે.

```jsx
class MyComponent extends React.PureComponent {
  render() {
    const { name, age } = this.props;
    return <div>{name} is {age}</div>;
  }
}
```

---

### **7. તમે ક્યારે `React.memo` નો ઉપયોગ કરશો?**

**ઉત્તર**:  
તમે `React.memo` નો ઉપયોગ ત્યારે કરવો જોઈએ:
- જ્યારે તમારા કોમ્પોનન્ટને એકજ પ્રોપ્સ ઘણી વાર મળતા હોય અને તમે અનાવશ્યક રીરેન્ડર્સથી બચવા માંગતા હો.
- જ્યારે કોમ્પોનન્ટ **pure** હોય, એટલે કે તે માત્ર પ્રોપ્સ પર આધાર રાખે છે અને તેમાં એવી આંતરિક સ્ટેટ બદલાવ નથી જે રેન્ડરિંગને પ્રભાવિત કરે.
- જ્યારે કોમ્પોનન્ટ જટિલ હોય અને વારંવાર રીડિરોંગના કારણે પ્રદર્શનનું એક મુદ્દો થઈ શકે.

---

### **8. શું `React.memo` હૂક્સ સાથે ઉપયોગ કરી શકાય છે?**

**ઉત્તર**:  
હા, `React.memo` હૂક્સનો ઉપયોગ કરનારા ફંક્શનલ કોમ્પોનન્ટ્સ સાથે ઉપયોગ કરી શકાય છે. તે પ્રોપ્સ બદલાવ પર આધારિત રીડિરોંગને ઑપ્ટિમાઇઝ કરે છે, અને તે `useState`, `useEffect` વગેરે જેવી હૂક્સ સાથે સીમલેસ કામ કરે છે.

```jsx
const MyComponent = React.memo(function MyComponent({ name }) {
  const [count, setCount] = useState(0);
  return <div>{name} - Count: {count}</div>;
});
```

---

### **9. `React.memo` અને `useMemo` વચ્ચે શું તફાવત છે?**

**ઉત્તર**:  
- **`React.memo`** એ સંપૂર્ણ કોમ્પોનન્ટને મેમોાઇઝ કરવા માટે વપરાય છે. તે ફંક્શનલ કોમ્પોનન્ટ્સને ઑપ્ટિમાઇઝ કરે છે જેથી પ્રોપ્સ બદલાવના આધારે અનાવશ્યક રીડિરોંગ રોકાય.
- **`useMemo`** એ હૂક છે જે ફંક્શનલ કોમ્પોનન્ટમાં ખર્ચાળ ગણતરીઓ અથવા મૂલ્યોને મેમોાઇઝ કરવા માટે વપરાય છે જેથી દરેક રીડિરોંગ પર તેમને ફરીથી ગણવું ન પડે.

```jsx
// React.memo નો ઉપયોગ
const MyComponent = React.memo(function MyComponent(props) { ... });

// useMemo નો ઉપયોગ
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

---

### **10. શું `React.memo` કોમ્પોનન્ટ્સના context સાથે ઑપ્ટિમાઇઝ કરવા માટે ઉપયોગ કરી શકાય છે?**

**ઉત્તર**:  
`React.memo` જ્યારે કોમ્પોનન્ટના context માં ફેરફાર થાય છે ત્યારે રીડિરોંગને રોકતો નથી. જો context મૂલ્ય બદલાય છે, તો `React.memo` કોમ્પોનન્ટને રી-રેન્ડર થવા માટે مجبور કરશે કારણ કે context મૂલ્યો શેલો કોમ્પેરિઝનમાં ભાગ નથી લેતા. તમે context અપડેટ્સને ઑપ્ટિમાઇઝ કરવા માટે `React.memo` નો ઉપયોગ કરી શકો છો, તેમજ ચાઈલ્ડ કોમ્પોનન્ટ્સને વધુ કાર્યક્ષમ રીતે context મૂલ્યો પસાર કરી શકો છો.

