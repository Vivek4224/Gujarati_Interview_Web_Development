1. What is JavaScript?
ans:- JavaScript એ એક ઓબ્જેક્ટ based પ્રોગ્રામિંગ language છે, જે મુખ્યત્વે HTML પેજ સાથે ક્લાયન્ટ-સાઇડ પ્રોગ્રામિંગ language તરીકે ઉપયોગ કરવામાં આવે છે, જેથી એમાં થોડું વર્તન (behavior) ઉમેરવામાં આવે.

પ્રથમ, JavaScript માત્ર બ્રાઉઝર માટે બનાવવામાં આવી હતી, પરંતુ હવે તે સર્વર અથવા કોઈપણ ક્લાયન્ટ પર ચલાવવામાં આવી શકે છે, જેમણે JavaScript એન્જિન ધરાવવી હોય. Node.js, MongoDB, jaggery.js, ASP જેવા પ્રોડક્ટ્સ સર્વર-સાઇડ JavaScript નો ઉપયોગ કરે છે.

બ્રાઉઝર માં JavaScript ઘણા કામો કરી શકે છે જેમ કે નીચે દર્શાવેલા છે:

HTML એલિમેન્ટ્સને મેનિપ્યુલેટ કરવું.
યૂઝર એકશન પર પ્રતિસાદ આપવો, જેમ કે જ્યારે યૂઝર માઉસ ક્લિક કરે અથવા કીબોર્ડનો ઉપયોગ કરે ત્યારે Event ચલાવવી.
રિમોટ સર્વર પર રિક્વેસ્ટ મોકલવી.
ફાઇલો ડાઉનલોડ અને અપલોડ કરવી.
કૂકીઝ મેળવી અને સેટ કરવી અને ક્લાયન્ટ-સાઇડ સ્ટોરેજ (લોકલ અને સેશન સ્ટોરેજ) હેન્ડલ કરવું.

JavaScript નો ઉપયોગ કરવાની મુખ્ય ફાયદાઓ:
HTML/CSS સાથે સંપૂર્ણ ઈન્ટિગ્રેશન.
બધા મુખ્ય બ્રાઉઝર્સ દ્વારા સપોર્ટેડ, જે સ્વચ્છ રીતે ડિફોલ્ટ પર ચાલુ હોય છે.



2. What is ECMAScript?

Ans: ECMAScript એ એક સ્ક્રિપ્ટિંગ language છે જે ECMA International દ્વારા ECMA-262 માં સ્ટાન્ડર્ડાઈઝ કરવામાં આવી છે. ActionScript, JavaScript અને ઘણી બીજી સ્ક્રિપ્ટિંગ language માં ECMAScript ઉપયોગમાં લેવામાં આવે છે. એમાં, JavaScript એ એક પ્રખ્યાત ક્લાયન્ટ-સાઇડ સ્ક્રિપ્ટિંગ language છે અને ECMAScript નું એક implementation છે, કારણ કે આ સ્ટાન્ડર્ડ પ્રકાશિત થયો હતો. હાલનું વર્ઝન ECMAScript 6 છે.

ECMAScript સામાન્ય રીતે JavaScript નું સ્ટાન્ડર્ડાઈઝડ વર્ઝન છે અને એક સામાન્ય ઉદ્દેશ માટેની પ્રોગ્રામિંગ language છે, જે JavaScript અને અન્ય languageઓમાં અમલમાં આવે છે. એ એક સ્ક્રિપ્ટિંગ language છે જેના પર આધારિત બ્રાઉઝર-આધારિત JavaScript અને Node.js પણ વિકસિત થયા છે.



3. Which data types are supported by JavaScript?

Ans: JavaScript એ ડાયનેમિકલી ટાઇપ્ડ language છે, એટલે કે, ત્યાં એક ડેટા ટાઇપ છે, પરંતુ તે ચોક્કસ પ્રકાર સાથે બાઉન્ડ નથી. Example તરીકે, જ્યારે વેરીએબલને ઇનિશિયાલાઈઝ કરવામાં આવે છે, તે સ્ટ્રિંગ પ્રકારનો હોઈ શકે છે, પરંતુ પછી તે નમ્બર મૂલ્ય પણ ધારણ કરી શકે છે.

JavaScript માં બે પ્રકારના ડેટા ટાઇપ્સ સપોર્ટ કરવામાં આવે છે: પ્રિમિટિવ ડેટા ટાઇપ્સ અને નોન-પ્રિમિટિવ ડેટા ટાઇપ્સ. નીચે JavaScript માં સપોર્ટ થયેલ કેટલાક ડેટા ટાઇપ્સ છે:

I. પ્રિમિટિવ ડેટા ટાઇપ્સ (Primitive Data Types):
String: ટેક્સ્ટ અથવા શબ્દોની શ્રેણી.
Number: આલ્જિબ્રાઇક અને એન્ટિગર નંબર્સ.
Boolean: સત્ય (true) અથવા ખોટું (false) મૂલ્ય.
Undefined: જ્યારે કોઈ વેરીએબલને મૂલ્ય આપાયું નથી ત્યારે તે undefined હોય છે.
Null: ખાલી અથવા ગેરમુલ્ય અથવા એન્શિઅલાઈઝ્ડ નથી થયેલું મૂલ્ય.
Symbol: અનન્ય અને અપક્ષય મૂલ્ય (ES6 માં ઉમેરાયું).
BigInt: મોટા પરિમાણોની સંખ્યા (ES11 માં ઉમેરાયું).

II. નોન-પ્રિમિટિવ ડેટા ટાઇપ્સ (Non-Primitive Data Types):
Object: કી-વેલ્યુ પેર માટે સ્ટોર કરાયેલી આકૃતિઓ (જેમ કે Array, ફંક્શન, વગેરે).
Array: સંખ્યાબંધ વેલ્યુઝની શ્રેણી (જેને ઇન્ડેક્સ દ્વારા access કરી શકાય છે).
Function: કોઈ ખાસ કાર્ય માટે લખાયેલા કોડના બ્લોક.



4. What is the difference between undefined and not defined?

Ans:

હવે નીચેના Example પર ધ્યાન દયી લો:
 Example 1 (undefined):
   var x;
   console.log(x);

   આ Exampleમાં, `x` એ ડિકલેર કરેલું છે, પરંતુ તેને કોઈ મૂલ્ય અસાઇન કરવામાં આવ્યું નથી. જ્યારે તમે કન્સોલમાં `x`ને લોગ કરશો, ત્યારે "undefined" મેસેજ મળશે. આનો અર્થ એ છે કે વેરીએબલ `x` ડિકલેર થયેલું છે અને તેની માટે મેમરી આલોકેટ કરવામાં આવી છે, પરંતુ તેને કોઈ વેલ્યુ અસાઇન કરી નથી.

 Example 2 (not defined):
   console.log(y);

   અહીં, `y` એ ન ડિકલેર કરેલું અને ન કોઈ વેલ્યુ અસાઇન કરવામાં આવી છે. જ્યારે તમે `y`ને લોગ કરવાનો પ્રયાસ કરો છો, ત્યારે "y is not defined" મેસેજ મળશે. આનો અર્થ એ છે કે `y` વેરીએબલ ક્યારેય ડિકલેર ન થયું હોય, એટલે મેમરી આલોકેટ નથી થઈ અને તેનો રેફરન્સ પણ ન મળી શકે.

મુખ્ય તફાવત:
- undefined: વેરીએબલ ડિકલેર થયેલું છે, પરંતુ તેને કોઈ મૂલ્ય અસાઇન નથી કરવામાં આવી.
- not defined: વેરીએબલ ક્યારેય ડિકલેર કરેલું નથી, એટલે તેને રેફરન્સ કરવાની કોશિશ કરવી એ ખોટું છે.



5. What is the use of typeof operator?

Ans:
typeof એ એક યુનરી ઓપરેટર છે, એટલે કે તે સ્ટેટમેન્ટ અથવા એક્સપ્રેશનમાં એક સિંગલ ઓપરન્ડ લે છે. આ ઓપરેટરનો ઉપયોગ તેના ઓપરન્ડનો ડેટા ટાઇપ ચેક કરવા માટે થાય છે, જે પછી સ્ટ્રિંગ સ્વરૂપે રિટર્ન થાય છે. Example તરીકે, જો આપણે undefind વેરીએબલ ચેક કરીએ તો typeof ઓપરેટર "undefined" તરીકે વેલ્યુ રિટર્ન કરશે.

var x = 10;
console.log(typeof(x));
આ કોડ કન્સોલમાં "number" પ્રિન્ટ કરશે.

var x = 10;
console.log(typeof(x) == 'number');
ઉપરોક્ત કોડથી, જો xનો પ્રકાર "number" હોય, તો આ એક્સપ્રેશન "true" પ્રિન્ટ કરશે.




6. What is the instanceof operator?

Ans: 

`instanceof` ઓપરેટર ચેક કરે છે કે કોઈ ઑબ્જેક્ટ એ કોઈ ક્લાસનું ઇન્સ્ટાન્સ છે કે નહીં.

function Country(name) { this.name = name; } 
var country = new Country("India");
console.log(country instanceof Country); // returns true

આ કોડથી, `country` ઓબ્જેક્ટ `Country` ક્લાસનો ઇન્સ્ટાન્સ છે, એટલે `true` રિટર્ન થશે.

આ ઓપરેટર હેરીટન્સને પણ ધ્યાનમાં રાખે છે.

let arr = ['apple', 'orange', 'grapes'];
console.log(arr instanceof Array); //prints true in console
console.log(arr instanceof Object); //prints true in console

અહીં, `arr` એ Array છે, પરંતુ તે ઓબ્જેક્ટના પણ એક ભાગ છે, કારણ કે Array પ્રોટોટાઇપ ઓબ્જેક્ટમાંથી હેરીટ કરતો છે.



7. What is the strict mode?

Ans:
“use strict” એ એક સ્ટેટમેન્ટ નથી, પરંતુ એક લિટરલ એક્સપ્રેશન છે જે ECMAScript સંસ્કરણ 5 દ્વારા સપોર્ટ કરવામાં આવ્યું છે. આ સ્ટેટમેન્ટ બ્રાઉઝરને(strict mode) સક્રિય કરવા માટે કહે છે, જે JavaScript માં વધુ સુરક્ષિત અને ખોટી ભૂલો દૂર કરવા માટે તૈયાર છે. આ સ્ટેટમેન્ટ કેટલીક JavaScript ની સિલેન્ટ ભૂલોને દૂર કરે છે.

Strict mode આખી સ્ક્રિપ્ટ અથવા વ્યક્તિગત ફંક્શન્સ પર લાગુ પડે છે, અને તે બ્લોક સ્ટેટમેન્ટ્સ અથવા કોડ (જે `{}` કળરી બ્રેસ દ્વારા ઢાંકેલ છે) પર લાગુ નથી પડતું. આ કોન્ટેક્સ્ટ્સમાં તે લાગુ પાડવાનો પ્રયાસ કરવો અર્થરહિત છે. eval કોડ, ફંક્શન કોડ, ઈવેંટ હેન્ડલર એટ્રિબ્યુટ્સ, setTimeout() અને સંબંધિત ફંક્શન્સમાં પણ strict mode લાગુ થાય છે, જે તેમને સિન્ટેક્સ અને ખોટી ભૂલો ચકાસવા માટે કાર્ય કરે છે.

Example:

"use strict";
x = 10; // આ error આપશે


ઉપરોક્ત સ્ટેટમેન્ટ એ error આપશે કેમ કે strict mode માં વેરીએબલનો ઉપયોગ કરવાનું પહેલા તેને ડિકલેર કરવું જરૂરી છે.

use strict expression gloabl અને લોકલ બંને scope માં લાગુ પડી શકે છે.

Global Scope:

const employee = { name: "Ram", age: 25 };
employee.name = "Raju"; // આ યોગ્ય છે 
"use strict";
x = 10; // આ error આપશે

Local Scope:

x = 10; // આ error આપશે નહીં 
myFunction();
function myFunction() {
    "use strict";
    y = 15; // આ error આપશે
}



8. Explain string in JavaScript.

Ans: 
JavaScript માં કૅરેક્ટર અથવા લખાણ ડેટાનું group એ "string" કહેવાય છે. JavaScript માં કોઈ અલગથી "character" પ્રકાર નથી, એટલે કે એક કૅરેક્ટર પણ string તરીકે સ્ટોર થાય છે. JavaScript માં, string ને સિંગલ કોટ્સ (' ') અથવા ડબલ કોટ્સ (" ") વડે ઘેરવામાં આવે છે.

પરંતુ JavaScript માં, પ્રિમિટિવ વેલ્યુઝ (જેમ કે string) માટે પણ methodઓ અને પ્રોપર્ટીઝ ઉપલબ્ધ છે, કારણ કે JavaScript methodઓ અને પ્રોપર્ટીઝને અમલ કરવા માટે પ્રિમિટિવ વેલ્યુઝને ઑબ્જેક્ટ તરીકે વર્તે છે.

Example:

var str = 'hello';
console.log(str); // આ "hello" પ્રિન્ટ કરશે.



9. search() અને indexOf() વચ્ચે શું તફાવત છે?

Ans: search() અને indexOf() method વચ્ચે નીચે મુજબના તફાવત છે:

- search(): આ method ઉપયોગ આપેલા મૂલ્યને શોધવા માટે થાય છે અને તે મેળ મળે તે જગ્યા (position) પર પાછું આપે છે. અહીં મૂલ્ય string અથવા regular expression હોઈ શકે છે.
  
- indexOf(): આ method ઉપયોગ આપેલા મૂલ્યને શોધવા માટે થાય છે અને તે મેળ મળે તે જગ્યા પર પાછું આપે છે. અહીં મૂલ્ય string હોવું જોઈએ, અને તે regular expression સ્વીકારતા નથી.

var m = /e/;
var str = "apple";
str.search(m)  // આ 4 આપે છે

var str = "apple";
str.indexOf(m)  // આ -1 આપે છે

સ્પષ્ટતા:
- `search()` regular expression સ્વીકારતું હોય છે, જ્યારે `indexOf()` માત્ર string સ્વીકારે છે. 
- `search()` method regex માટે શોધી શકે છે, પરંતુ `indexOf()` method માત્ર સ્પષ્ટ string માટે કામ કરે છે.



10. indexOf() અને lastIndexOf() વચ્ચે શું તફાવત છે?

Ans: indexOf() અને lastIndexOf() methodઓ વચ્ચે નીચે મુજબના તફાવત છે:

- indexOf(): આ method એ string માં specific text ની પ્રથમ Occurrence (ઘટના) નું ઇન્ડેક્સ આપે છે.
  
- lastIndexOf(): આ method એ string માં specific text ની છેલ્લી Occurrence (ઘટના) નું ઇન્ડેક્સ આપે છે.

var str = 'Hello find me test me';
str.indexOf('me') // આ 11 આપે છે, કારણકે 'me' પ્રથમ વખત 11 પર આવે છે

var str = 'Hello find me test me';
str.lastIndexOf('me') // આ 19 આપે છે, કારણકે 'me' છેલ્લીવાર 19 પર આવે છે

સ્પષ્ટતા:
- `indexOf()` method string માં અનુક્રમણિકા મુજબ પહેલીવાર એ લખાણ શોધી આપે છે.
- `lastIndexOf()` method string માં એ લખાણની છેલ્લીવારની occurrence નું ઇન્ડેક્સ આપે છે.



11. substr() અને substring() વચ્ચે શું તફાવત છે?

Ans: substr() અને substring() method વચ્ચે નીચે મુજબના તફાવત છે:

- substr(): આ method એ string માં specified ઇન્ડેક્સથી શબ્દો શરૂ કરે છે અને આપેલા length મુજબ કેટલા અક્ષરો મેળવવા છે તે આપે છે.

- substring(): આ method એ string માં specified ઇન્ડેક્સથી શબ્દો શરૂ કરે છે, પરંતુ length 1 દ્વારા ઘટી જાય છે (અર્થાત, તે આપેલા 2 માનથી 1 ઓછા અક્ષરો આપે છે).

var x = "hello";
console.log((x.substr(1, 4) == "ello")) // આ log માં true પ્રિન્ટ કરશે

var x = "hello";
console.log((x.substring(1, 4) == "ello")) // આ log માં false પ્રિન્ટ કરશે

var x = "hello";
console.log((x.substring(1, 5) == "ello")) // આ log માં true પ્રિન્ટ કરશે

સ્પષ્ટતા:
- `substr()` method, બીજા પરિમાણ તરીકે આપેલા length મુજબ કેટલા અક્ષરો આવશે તે એન્કોડિંગથી નક્કી થાય છે.
- `substring()` method, બીજું પરિમાણ સંખ્યાનું મર્યાદા 1 થી ઘટી જાય છે, એટલે કે આપેલા બંને ઇન્ડેક્સ વચ્ચેના અક્ષરો પાછા આપે છે, 1 ઓછા.



12. Array અને Object વચ્ચે શું તફાવત છે?

Ans: Array અને Object વચ્ચે નીચે મુજબના તફાવત છે:

# Array:- 
Array એ numbered indexes નો ઉપયોગ કરીને એલેમેન્ટને access કરે છે.
જ્યારે તમે એલેમેન્ટનું નામ number તરીકે રાખવા માંગો છો ત્યારે array નો ઉપયોગ કરો.
Array ordered collection છે.

# Object:- 
Object એ named indexes નો ઉપયોગ કરીને એલેમેન્ટને નાં members (મેમ્બર)ને access કરે છે.
જ્યારે તમે એલેમેન્ટનું નામ string તરીકે રાખવા માંગો છો ત્યારે object નો ઉપયોગ કરો.
Object unordered properties નો કલેક્શન છે.

આવું થશે:

- Array: જ્યાં વ્યક્તિગત વસ્તુઓનો ક્રમ મહત્વપૂર્ણ હોય અને તમે numbered indexes વડે values access કરવા માગતા હો, ત્યાં array સૌથી યોગ્ય હોય છે.
  
- Object: જ્યારે તમને values માટે key-value pair structure કે string-based key દ્વારા values રાખવી હોય, ત્યારે object વધુ યોગ્ય છે.



13. Self-executing function શું છે?

Ans: Self-executing function એ એવી ફંક્શન છે જે તેના ડિફાઇન થયા પછી તરત જ એક્ઝિક્યુટ (ચલાવવાં) થાય છે. આનો ફાયદો એ છે કે આ ફંક્શન કોડને ગ્લોબલ ડીક્લેર કર્યા વિના ચલાવશે. આ પ્રકારની ફંક્શન સામાન્ય રીતે DOM એલેમેન્ટ્સ પર event listeners લગાવવા અને અન્ય initialization કાર્ય માટે ઉપયોગમાં લેવાય છે.

આ પ્રકારની self-executing function એ નામ વગરની ફંક્શન હોય છે, જેને anonymous function કહેવામાં આવે છે. આ ફંક્શનની પાછળ parentheses (ગોળાં) હોય છે, જેમાં કોઈ આર્ગ્યુમેન્ટ્સ ના હોય. આ ફંક્શન માટે પેરામિટર્સ parentheses માં પસાર કરી શકાય છે.

નીચે એક સરળ Example છે જે anonymous function ના ઉપયોગને દર્શાવે છે:
(function () {
    // function body
})();

સ્પષ્ટતા: 
- Self-executing function ને તરત જ execute કરવું એ તેની વિશિષ્ટતા છે. 
- તેમાં parentheses છે જે function call માટે જરૂરિયાત છે, અને તેનું કોઈ નામ નથી, એટલે તે anonymous function કહેવાય છે. 



14. Arrow function શું છે?

Ans: Arrow function એ Javascript માં ES6 (ECMAScript 6) અને તેનાથી ઉપરના વર્ઝન્સમાં આધારિત ફંક્શન છે, જે ફંક્શન એક્સપ્રેશન્સ લખવાની એ સરળ અને ટૂંકી રીત છે.

Arrow function એ એવા ફંક્શન માટે એક ટૂંકું સંકેત છે જેનું પોતાનું "this" નથી. નીચે એક સરળ Example છે જે આનો ઉપયોગ દર્શાવે છે.

સામાન્ય function:

function add(a, b) {
    return a + b;
}
console.log(add(1, 2)); // 3

Arrow function નો ઉપયોગ:

add = (a, b) => { 
    return a + b; 
}
console.log(add(1, 2)); // 3

સ્પષ્ટતા:
- Arrow functions લખવામાં ટૂંકા અને સરળ છે, અને તેને `=>` સંકેતથી ઓળખી શકાય છે.
- Arrow function ના સ્વરૂપમાં, "this" એ ફંક્શનનો ભાગ નથી, અને તે તેલના સ્કોપ (lexical scope) સાથે જોડાય છે, જે સામાન્ય functions કરતા અલગ હોય છે.



15. વેબ પેજ ચલાવતી બ્રાઉઝર કેવી રીતે શોધવી?  

Ans: તે બ્રાઉઝર શોધવા માટે જે હાલમાં વેબ એપ્લિકેશન ચલાવી રહી છે, `window` ઓબ્જેક્ટનો `navigator` ઉપયોગ કરવામાં આવે છે.  

var browsername = navigator.appName;
console.log(browsername);



16. યૂઝરને નવી પેજ પર કેવી રીતે રીડાયરેક્ટ કરવું?

Ans: `window` ઓબ્જેક્ટના `location` નો ઉપયોગ કરી શકીએ છીએ, જેમાં HREF URL લિંક આપીને યૂઝરને નવી પેજ પર રીડાયરેક્ટ કરી શકાય છે.  

window.location.href="https://www.dotnettricks.com/";



17. નીચેના કોડનું આઉટપુટ શું છે?

var num = "10"; 

(function () {
    console.log("Original Number " + num); 
    var num = "50"; // આ ઇન્નર વેરિએબલ છે
    console.log("New Number " + num); 
})();

Ans: આ કોડમાં `num` વેરિએબલનો મૂલ્ય બદલી રહ્યો છે, પરંતુ તેમ છતાં JavaScriptના hoisting નિયમોને કારણે `num` ને પહેલા `undefined` દર્શાવશે. 

આનો અર્થ એ છે કે:

1. જ્યારે `console.log("Original Number " + num);` કરવામાં આવે છે, ત્યારે `num`નું મૂલ્ય `undefined` હોઈ કારણ કે તેમાં `var num = "50";` ઘટક પહેલાં ફંક્શન સ્કોપમાં hoisting થાય છે.
2. પછી, `num`ને `"50"` તરીકે અસાઇન કરવામાં આવે છે, તેથી બીજા `console.log("New Number " + num);` માં `"50"` દર્શાવશે.

આઉટપુટ:
Original Number undefined
New Number 50



18. DOM શું છે?  

Ans: DOM એ W3C (World Wide Web Consortium) ધોરણ છે. જ્યારે HTML પેજ બ્રાઉઝરમાં લોડ થાય છે, ત્યારે બ્રાઉઝર DOM (Document Object Model) બનાવે છે. આ HTML element ઓબ્જેક્ટ તરીકે વ્યાખ્યાયિત કરે છે અને સ્ક્રિપ્ટોને document ની properties અને રચનામાં dynamic રીતે ફેરફાર કરવા માટેની અનુમતિ આપે છે.

જ્યારે કોઈ HTML Document બ્રાઉઝરમાં લોડ થાય છે, તે Document ઓબ્જેક્ટ બની જાય છે, જે HTML Documentનું root element છે. દરેક DOM element માં વિવિધ પ્રોપર્ટી અને method હોય છે. અને Document ઑબ્જેક્ટ્સની મદદથી, વેબ પેજ પર જરૂરી વર્તન મુજબ dynamic content ઉમેરવા માટે powerfull રીતે work કરી શકીએ છીએ.

HTML:

<!DOCTYPE html>
<html lang="en">
<body> 
 <h1>Document Object Model</h1>
</body>
</html>

DOM માં, દરેક HTML એ એક ઑબ્જેક્ટ છે, નેસ્ટ કરેલા ટેગ્સ "children" છે, અને `<h1>`ની અંદરનો લખાણ પણ એક ઑબ્જેક્ટ છે.

DOM આઇટમનો tree

DOM એ HTMLને ટેગ્સની tree રચનામાં દર્શાવે છે. આ બ્રાઉઝરમાં "Inspect Element"ના ઉપયોગથી કેવી રીતે દેખાય છે, તે પ્રદર્શન કરે છે.



19. BOM શું છે?  

Ans: BOM (Browser Object Model) બ્રાઉઝર સાથેની interaction provides કરે છે, બ્રાઉઝરનો ડિફોલ્ટ ઓબ્જેક્ટ `window` છે. વિન્ડોઝ દ્વારા provides કરવામાં આવતી વિવિધ પ્રોપર્ટીઓમાં Document, history, screen, location, and navigator શામેલ છે.

આધુનિક બ્રાઉઝર્સે JavaScript Opration માટે BOM ની method અને પ્રોપર્ટીઓ માટે એક જ method અને પ્રોપર્ટીઓ અમલમાં મૂકીને BOM ને માન્ય બનાવ્યું છે. `window` ઓબ્જેક્ટ એ automatically બ્રાઉઝર દ્વારા બનાવવામાં આવે છે.



20. JavaScript માં NaN પ્રોપર્ટી શું છે?  

Ans: NaN પ્રોપર્ટી "Not-a-Number" value ને દર્શાવે છે. આ તે value છે જે Legaly સંખ્યા નથી. જો તમે ચેક કરવા માંગતા હોવ કે કોઈ મૂલ્ય NaN છે કે નહીં, તો `isNaN()` ફંક્શનનો ઉપયોગ કરવામાં આવે છે. મહત્વપૂર્ણ એ છે કે `isNaN()` ફંક્શન આપેલા value ને number type માં convert કરે છે અને પછી તે NaN સાથે compare કરે છે.



21. `window` ઓબ્જેક્ટની ઉપયોગિતા શું છે? 

બ્રાઉઝરના `history` ઓબ્જેક્ટનો ઉપયોગ હાલની પેજ અથવા બીજી પેજમાંથી Historical pages navigation માટે થાય છે, જેમ કે આગળ અને પાછળ જવાનો. `history` ઓબ્જેક્ટની 3 મુખ્ય method નીચે મુજબ છે:

- `history.back()` – આ method અગાઉનો પેજ લોડ કરે છે.  
- `history.forward()` – આ method આગળનો પેજ લોડ કરે છે.  
- `history.go(number)` – આ સંખ્યા પોઝિટિવ (આગળ જવા માટે) અથવા નેગેટિવ (પાછળ જવા માટે) હોઈ શકે છે. તે આપેલા page નંબરને લોડ કરશે.  



22. JavaScript માં ટાઈમર્સનું કાર્ય શું છે?  

Ans: ટાઈમર્સ એ કોઈ ચોક્કસ સમય પર કોડના piece ચલાવવા અથવા ચોક્કસ સમયાંતરે કોડને recurrence કરવા માટે ઉપયોગી હોય છે. આ કાર્ય `setInterval`, `setTimeout`, અને `clearInterval` જેવી પદ્ધતિઓનો ઉપયોગ કરીને કરવામાં આવે છે. ટાઈમર્સ એક સિંગલ થ્રેડમાં કાર્ય કરે છે, તેથી તે queue up થાઈ શકે છે અને અમુક સમયે અમલ માટે રાહ જોઈ શકે છે.

`setTimeout(function, delay)` પદ્ધતિ એ એવા ટાઈમરને શરૂ કરવા માટે ઉપયોગી છે જે આપેલી Delay પછી ચોક્કસ કાર્યને બોલાવે છે.  
`setInterval(function, delay)` પદ્ધતિ આપેલા વિલંબમાં Skillfully રીતે આપેલી કાર્યને કાર્યાન્વિત કરે છે અને માત્ર ત્યારે રોકાય છે જ્યારે તેને રદ કરવામાં આવે.  
ટાઈમર સ્ટોપ કરવા માટે `clearInterval(id)` પદ્ધતિનો ઉપયોગ થાય છે.



23. JavaScript માં વિવિધ પ્રકારના error શું છે? 
 
Ans: JavaScript માં ત્રણ પ્રકારના error છે:

1. રનટાઇમ error: આ એ error છે જે HTML language માં કમાન્ડના દુરુપયોગથી થાય છે.
2. લોડ ટાઇમ error: આ error વેબ પેજ લોડ કરતી વખતે થાય છે. Example તરીકે, ખોટી  syntax ભૂલો જે error ને dynamically રીતે produce કરે છે.
3. લોજિકલ error: આ error ખોટા લોજિકના કારણે થાય છે, જેમ કે કોઈ function પર varied operation કરવા.



24. "this" કીવર્ડને સમજાવો.  

"this" કીવર્ડ તે ઓબ્જેક્ટને દર્શાવે છે જે ફંક્શનનો પ્રોપર્ટી હોય છે. "this" કીવર્ડનો મૂલ્ય એ ઓબ્જેક્ટ પર આધાર રાખે છે જે ફંક્શનને call કરે છે.

Example:

var obj = {
    name: "ScholarHat",
    getName: function() {
        console.log(this.name);
    }
} 
obj.getName();

ઉપરોક્ત કોડમાં, call કરતી વખતે, `getName` ફંક્શન ઓબ્જેક્ટ `obj` ની પ્રોપર્ટી છે, તેથી "this" કીવર્ડ ઓબ્જેક્ટ `obj` ને સંબોધે છે, અને આ માટે આઉટપુટ "ScholarHat" થશે.



25. `.call()` અને `.apply()` વચ્ચેનો તફાવત સમજાવો.  

Ans: `.apply()` અને `.call()` ફંક્શનનું ઉપયોગ ખૂબ જ સમાન છે, પરંતુ થોડી બેદલાવ હોય છે. 

- `.call()`: જ્યારે પ્રોગ્રામર ને ફંક્શનના આર્ગ્યુમેન્ટ્સની સંખ્યા જાણે છે, ત્યારે `.call()` નો ઉપયોગ થાય છે. આ આર્ગ્યુમેન્ટ્સને સીધા `.call()` સ્ટેટમેન્ટમાં પેરામીટર્સ તરીકે આપવું પડે છે.

- `.apply()`: જ્યારે આર્ગ્યુમેન્ટ્સની સંખ્યા unknown હોય, ત્યારે `.apply()` નો ઉપયોગ થાય છે. `.apply()` માટે આર્ગ્યુમેન્ટ એ Array ફોર્મેટમાં આપવું પડે છે.

પ્રમુખ તફાવત: આ બંને ફંક્શનનો મુખ્ય તફાવત એ છે કે તેઓ આર્ગ્યુમેન્ટ્સને ફંક્શન સુધી કેવી રીતે send કરે છે. `.call()` આર્ગ્યુમેન્ટ્સને અલગથી provide કરે છે, જ્યારે `.apply()` એ એક Array તરીકે pass થાય છે. 

Ans:

function greet(message, name) {
    console.log(message + " " + name);
}

greet.call(null, "Hello", "John");  // Output: Hello John
greet.apply(null, ["Hello", "John"]);  // Output: Hello John


ઉપરના કોડમાં, `.call()` અને `.apply()` બંને પદ્ધતિઓ `"Hello John"` આઉટપુટ આપે છે, પરંતુ `.call()` પેરામીટર્સને સીધા પાસ કરે છે, અને `.apply()` એ Array સ્વરૂપમાં પેરામીટર્સ લે છે.



26. JavaScript માં DOM કેવી રીતે ઉપયોગી છે? 

Ans: DOM (Document Object Model) એ document માં વિવિધ ઓબ્જેક્ટ્સની પરસ્પર Action નિયંત્રિત કરવા માટે જવાબદાર છે. આ વેબ પેજો develop માટે ઉપયોગી છે જે લિંક, પેરાગ્રાફ અને અન્ય ઓબ્જેક્ટ્સ ધરાવે છે. આવા ઓબ્જેક્ટ્સ પર Action લાગૂ કરી શકાય છે જેમ કે ઉમેરવું અથવા કાઢી નાખવું. એ ઉપરાંત, DOM એ વેબ પેજને વધારાના ફીચર્સ અને ક્ષમતા પ્રદાન કરવા માટે પણ ઉપયોગી છે. APIના ઉપયોગથી અન્ય Distortion મોડલ્સની તુલનામાં વધુ લાભ મળે છે.



27. JavaScript માં deferred સ્ક્રિપ્ટ્સનો role શું છે?  

Ans: પેજ loading દરમિયાન HTML કોડનું parsing default રીતે અટકાવવામાં આવે છે, જ્યાં સુધી સ્ક્રિપ્ટ execute કરવામા ન આવે. સર્વર slow speed થી કામ કરતો હોય અથવા સ્ક્રિપ્ટ મોટું હોય ત્યારે વેબપેજ લોડ થવામાં વિલંબ થાય છે.

ત્યારે deferred નો ઉપયોગ થાય છે, સ્ક્રિપ્ટ્સના અમલને HTML parser કાર્યરત થવા સુધી વિલંબિત કરવામાં આવે છે. આ રીતે, વેબ પેજનું લોડિંગ સમય ઘટે છે અને તે ઝડપી દેખાય છે.



28. JavaScript માં different functional components શું છે?  
Ans:  functional components JavaScript કોર્સમાં આવરી લેવામાં આવતી મહત્વપૂર્ણ ટોપિક્સ છે. JavaScript માં બે પ્રકારના  functional  components છે – ફર્સ્ટ-ક્લાસ ફંક્શન અને નેસ્ટેડ ફંક્શન.

i. ફર્સ્ટ-ક્લાસ ફંક્શન: JavaScript માં આ ફંક્શનને ફર્સ્ટ-ક્લાસ ઓબ્જેક્ટ્સ તરીકે ઉપયોગ કરવામાં આવે છે. સામાન્ય રીતે, તેનો અર્થ એ છે કે આવા ફંક્શન્સને બીજાં ફંક્શનના પેરામીટર તરીકે પાસ કરી શકાય છે. તે બીજાં ફંક્શન્સથી મૂલ્ય તરીકે પરત આપાતા હોય છે, વેરિએબલ્સમાં અસાઇન થઇ શકે છે, અથવા ડેટા સ્ટ્રક્ચર્સમાં સંગ્રહિત કરી શકાય છે.

ii. નેસ્ટેડ ફંક્શન: આ એવા ફંક્શન્સ છે જે અન્ય ફંક્શન્સની અંદર defined કરવામાં આવે છે, જેને નેસ્ટેડ ફંક્શન્સ કહેવામાં આવે છે. જ્યારે મુખ્ય ફંક્શન call
થાય છે, ત્યારે નેસ્ટેડ ફંક્શન્સ પણ call થાય છે.



29. JavaScript માં HTML element access કરવાની વિવિધ રીતો શું છે?  
Ans: HTML element કૅપ્ચર કરવા અને તેને મેનિપ્યુલેટ કરવા માટે નીચેના DOM પદ્ધતિઓનો ઉપયોગ થાય છે.

1.`getElementById('idname')` – આ પદ્ધતિ HTML તત્વને તેના ID પ્રોપર્ટી દ્વારા પસંદ કરવા માટે ઉપયોગ થાય છે.  

Example:

<!DOCTYPE html>
<html>
<head>
 <meta charset="utf-8" />
 <title></title>
</head>
<body>
 <label id="myelement"></label>
 <script>
   document.getElementById('myelement').innerHTML = '<h3> Welcome </h3>'
 </script>
</body>
</html>

આ કોડમાં, `getElementById('myelement')` એ `myelement` ID ધરાવતો લેબલ તત્વ પસંદ કરી "Welcome" લખેલું HTML સેટ કરે છે.


2. `getElementsByClassName('className')` – આ પદ્ધતિ HTML element તેમના ક્લાસ નામ આધારિત પસંદ કરવા માટે ઉપયોગ થાય છે. આ પદ્ધતિ તે તમામ HTML element પરત આપે છે જે ક્લાસ નામ સાથે મેચ થાય છે.

Example:

<!DOCTYPE html>
<html>
<head>
 <meta charset="utf-8" />
 <title></title>
</head>
<style>
 .lblMsg {
   color: #000;
 }
</style>
<body>
 <label id="myelement" class="lblMsg"></label>
 <script>
   document.getElementsByClassName('lblMsg')[0].innerHTML = '<h3> Welcome </h3>'
 </script>
</body>
</html>

આ કોડમાં, `getElementsByClassName('lblMsg')` એ `lblMsg` ક્લાસ ધરાવતું લેબલ તત્વ પસંદ કરે છે અને "Welcome" લખવાનું નવું HTML સેટ કરે છે.


3. `getElementsByTagName('HTMLtagname')` – આ પદ્ધતિ HTML element તેમના ટેગ નામ આધારિત પસંદ કરવા માટે ઉપયોગ થાય છે. આ પદ્ધતિ તે તમામ HTML element પરત આપે છે જે ટેગ નામ સાથે મેચ થાય છે.

Example:

<!DOCTYPE html>
<html>
<head>
 <meta charset="utf-8" />
 <title></title>
</head>
<style>
 .lblMsg {
   color: #000;
 }
</style>
<body>
 <label id="myelement" class="lblMsg"></label>
<script>
 document.getElementsByTagName('label')[0].innerHTML = '<h3> Welcome </h3>'
</script>
</body>
</html>

આ કોડમાં, `getElementsByTagName('label')` એ `label` ટેગ ધરાવતું HTML તત્વ પસંદ કરે છે અને "Welcome" લખવાનું નવું HTML સેટ કરે છે.



30. ફંક્શન ડિકલેરેશન્સ અને ફંક્શન એક્સપ્રેશન વચ્ચેનો તફાવત શું છે?  

Ans:  

- ફંક્શન ડિકલેરેશન: ફંક્શન ડિકલેરેશનને function કીવર્ડનો ઉપયોગ કરીને વ્યાખ્યાયિત કરવામાં આવે છે. ફંક્શન ડિકલેરેશન્સ hoisted થાય છે, એટલે કે ફંક્શનના નિર્ધારણ પછી, ફંક્શનને કોડના એન્ડમાં પણ કૉલ કરી શકાય છે.

Example:

function greet() {
    console.log("Hello, World!");
}
greet(); // Output: Hello, World!

- ફંક્શન એક્સપ્રેશન: ફંક્શન એક્સપ્રેશન એ છે જ્યારે એક ફંક્શનને વેરિએબલમાં અસાઇન કરવામાં આવે છે. ફંક્શન એક્સપ્રેશન્સ hoisted નથી, એટલે કે તેને ઉપયોગ પહેલા વ્યાખ્યાયિત કરવાની જરૂર પડે છે.

Example:

var greet = function() {
    console.log("Hello, World!");
};
greet(); // Output: Hello, World!

પ્રધાન તફાવત:
- ફંક્શન ડિકલેરેશન્સ હોઈસ્ટેડ થાય છે, જ્યારે ફંક્શન એક્સપ્રેશન્સ હોઈસ્ટ નથી.
- ફંક્શન ડિકલેરેશન્સ સીધી રીતે `function` કીવર્ડથી બનાવવામાં આવે છે, અને ફંક્શન એક્સપ્રેશન્સ વેરિએબલમાં ફંક્શન અસાઇન કરવામાં આવે છે.



32. JavaScript માં TypedArray ઓબ્જેક્ટનો ઉપયોગ શું છે?  

Ans:  

JavaScript માં TypedArray ઓબ્જેક્ટ એ Array જેવી નમૂનાઓ છે.

TypedArray ઓબ્જેક્ટનો ઉપયોગ બાઈનરી ડેટાને સંગ્રહિત કરવા અને પ્રોસેસ કરવા માટે થાય છે, જેમ કે ગ્રાફિક્સ, નેટવર્ક પ્રોટોકોલ, અને અન્ય દૃશ્યમય ડેટા.

Example:

function display()  
{  
  var arr1 = [11, 12, 3, 4, 5, 6, 17, 8, 9, 10];     
  arr1.copyWithin(2);   
  document.write(arr1);    
}  
display();

સમજૂતી:
- આ કોડમાં, `copyWithin()` પદ્ધતિ Arrayના તત્વોનું કોપી કરવા માટે ઉપયોગ થાય છે. આ method દરેક તત્વને હવે Array ના બીજા ભાગમાં પોસીશન ને  નિયંત્રિત કરે છે.  
- આ કોડના પરિણામે, `arr1` Array માં તત્વો સુધરાઈને અન્ય જગ્યાએ પોસીશન પામે છે.

TypedArray નો ઉપયોગ, ખાસ કરીને મોટા બાઇનરી ડેટાને મેનેજ કરતી વખતે, વધુ કાર્યક્ષમ અને ઝડપી ડેટા પ્રોસેસિંગ માટે થાય છે.



33. WeakSet in JavaScript શું છે?

Ans:

JavaScriptમાં, Set એ અનોખા અને ક્રમબધ્ધ તત્વોની સંગ્રહ છે. તે પણ અનોખા અને ક્રમબધ્ધ તત્વોની સંગ્રહ ધરાવતો છે, પરંતુ WeakSet માં કેટલીક મુખ્ય તફાવતો છે:

1. WeakSet માત્ર ઑબ્જેક્ટ્સને જ સંગ્રહિત કરે છે, કોઈ બીજા પ્રકારના તત્વોને નહીં.
2. WeakSet માં એક ઑબ્જેક્ટને વિશિષ્ટ રીતે રેફરન્સ કરવામાં આવે છે. તેનો અર્થ એ છે કે જો WeakSet માંથી કોઈ ઑબ્જેક્ટનો રેફરન્સ સમાપ્ત થાય છે, તો તે ઑબ્જેક્ટ ગાર્બેજ કલેક્શન દ્વારા મચાવાઈ જાય છે.
3. WeakSet માં Set ની સરખામણીમાં માત્ર ત્રણ પદ્ધતિઓ છે: `add()`, `delete()`, અને `has()`.

Example 1: 

const newSet = new Set([4, 5, 16, 7]);
console.log(newSet); // આ આઉટપુટ કરશે: Set {4, 5, 16, 7}

Example 2: 

const newSet2 = new WeakSet([3, 4, 5]); // આ ખોટું હશે, કારણ કે WeakSet માત્ર ઑબ્જેક્ટ્સને જ સ્વીકારતું છે

આ કોડમાં એરેને WeakSet પર લાગુ કરવામાં આવશે, જે સેટની માત્ર ઑબ્જેક્ટ્સની સ્વીકાર્યતા નથી, અને આ માટે ત્રુટિ આવશે.

Example 3:

let obj1 = { message: "Hello ScholarHat" };
const newSet3 = new WeakSet([obj1]);
console.log(newSet3.has(obj1)); // true

આ કોડમાં, `obj1` એ WeakSet માં ઉમેરી શકાય છે અને `has()` પદ્ધતિનો ઉપયોગ કરીને ચકાસવામાં આવશે કે તે WeakSet માં છે કે કેમ. આ કોડને સાચું આવકારશે. 

WeakSet નો ઉપયોગ: WeakSet તે પરિસ્થિતિઓમાં ઉપયોગી છે જ્યાં તમે એ ઑબ્જેક્ટ્સને ટ્રીક કરી રહ્યા છો જે ગાર્બેજ કલેક્શનને યોગ્ય રીતે પકડી શકે છે, જેમ કે DOM elements અથવા અન્ય મેમરી સંગ્રહો.